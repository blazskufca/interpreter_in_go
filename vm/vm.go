package vm

import (
	"errors"
	"fmt"
	"github.com/blazskufca/interpreter_in_go/code"
	"github.com/blazskufca/interpreter_in_go/compiler"
	"github.com/blazskufca/interpreter_in_go/object"
)

const StackSize = 2048

// GlobalsSize is 65536, because code.OpGlobalGet and code.OpGlobalSet have a single 2 byte operand...Meaning the maximum range
// is what the value GlobalSize is set to.
const GlobalsSize = 65536

// MaxFrames is the maximum number of *Frame in VM.frames stack.
const MaxFrames = 1024

// True is a global *object.Boolean with a value of true which the Monkey VM reuses anytime it needs a true boolean.
var True = &object.Boolean{Value: true}

// False is a global *object.Boolean with a value of false which the Monkey VM reuses anytime it needs a false boolean.
var False = &object.Boolean{Value: false}

// Null represents a value or lack there of a value. It's used when expressions in Monkey evaluate to "nothing"
var Null = &object.Null{}

// VM represent a Monkey Virtual Machine - The heart of the bytecode interpreter, which executes/evaluates bytecode
// produced by compiler.Compiler.
// Monkey virtual machine is a stack based virtual machine.
type VM struct {
	constants []object.Object // constants are the evaluated literals and other constants from the compiler.Compiler constants pool
	stack     []object.Object // stack is the Monkey virtual machine stack
	// sp is the Stack Pointer (https://www.techtarget.com/whatis/definition/stack-pointer).
	// It always points to the next value.
	// Top of the stack is stack[ sp -1 ].
	sp          int
	globals     []object.Object // globals is the evaluated global store
	frames      []*Frame        //  frames is a Frame stack.
	framesIndex int             // framesIndex tracks all the Frame in frames stack
}

// currentFrame returns a pointer to a frame sitting on top of the VM.frames (VM.framesIndex - 1)
func (vm *VM) currentFrame() *Frame {
	return vm.frames[vm.framesIndex-1]
}

// pushFrame pushes a new frame into VM.frames and increments the VM.framesIndex.
func (vm *VM) pushFrame(f *Frame) {
	vm.frames[vm.framesIndex] = f
	vm.framesIndex++
}

// popFrame pops the frame on top of the VM.frames (VM.framesIndex), decrements the VM.framesIndex and returns the popped
// frame to the caller.
func (vm *VM) popFrame() *Frame {
	vm.framesIndex--
	return vm.frames[vm.framesIndex]
}

// New returns a pointer to a new, initialized, Monkey virtual machine.
// Note that VM.stack is initialized to a slice with size of StackSize.
// VM.sp is initialized to 0, as you might expect.
// A new, main Frame (NewFrame) is created and pushed onto the frame stack.
func New(bytecode *compiler.Bytecode) *VM {
	mainFn := &object.CompiledFunction{Instructions: bytecode.Instructions}
	mainFrame := NewFrame(mainFn)
	frames := make([]*Frame, MaxFrames)
	frames[0] = mainFrame
	return &VM{constants: bytecode.Constants,
		stack:       make([]object.Object, StackSize),
		sp:          0,
		globals:     make([]object.Object, GlobalsSize),
		frames:      frames,
		framesIndex: 1,
	}
}

// NewWithGlobalsStore returns a pointer to a new VM with preset Globals.
func NewWithGlobalsStore(bytecode *compiler.Bytecode, s []object.Object) *VM {
	vm := New(bytecode)
	vm.globals = s
	return vm
}

// StackTop returns an object.Object on top of the stack, object at position VM.stack[VM.sp - 1], to the caller.
// If the VM stack is empty, nil is returned to the caller instead!
// This is a DEPRECATED method. You probably want to call LastPoppedStackElem instead, since VM auto-cleans the stack
// with expression statements and similar, meaning this method will give you incorrect results.
func (vm *VM) StackTop() object.Object {
	if vm.sp == 0 {
		return nil
	}
	return vm.stack[vm.sp-1]
}

// LastPoppedStackElem will return the last object.Object which the VM has popped of its stack.
func (vm *VM) LastPoppedStackElem() object.Object {
	// This works because our vm.sp always points at the NEXT spot on the stack (i.e. FREE SPOT where the next element will be pushed).
	// But we pop by just decrementing the stack pointer...We don't remove them from the underlying stack implementation (slice), they are not set to nil...
	// that spot is just marked as free, meaning we can simpy check what was there
	return vm.stack[vm.sp]
}

// Run is the heartbeat itself of the Monkey virtual machine, if you take analogy of the VM structure being a heart.
// It mimics and performs the fetch–decode–execute cycle (https://en.wikipedia.org/wiki/Instruction_cycle) on the
// bytecode generated by compiler.Compiler.
func (vm *VM) Run() error {
	var ip int
	var ins code.Instructions
	var OPCODE code.Opcode
	for vm.currentFrame().ip < len(vm.currentFrame().Instructions())-1 {
		vm.currentFrame().ip++
		ip = vm.currentFrame().ip
		ins = vm.currentFrame().Instructions()
		OPCODE = code.Opcode(ins[ip])
		// We take the first byte, which is always a OPCODE and we cast it said type.
		// Note that it's important that we do not use  code.Lookup here to get from a byte to an Opcode.
		// That would be far TOO SLOW. It costs time to move the byte around, lookup the opcode’s definition, return
		// it and take it apart.
		switch OPCODE {
		case code.OpConstant:
			// code.OpConstant are uint16 indexes into the constants pool.
			// Therefore, what we need to do first is decode this number, the index.
			constIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2 // Again, since code.OpConstant is uint16 this means we need to advance 2 bytes afterward
			// This is the execute part of the fetch-decode-execute cycle for constants/literals
			// We push the constant onto the VM's stack!
			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}
		case code.OpAdd, code.OpSub, code.OpMul, code.OpDiv:
			err := vm.executeBinaryOperation(OPCODE)
			if err != nil {
				return err
			}
		case code.OpPop:
			_ = vm.pop()
		case code.OpTrue:
			err := vm.push(True)
			if err != nil {
				return err
			}
		case code.OpFalse:
			err := vm.push(False)
			if err != nil {
				return err
			}
		case code.OpEqual, code.OpNotEqual, code.OpGreaterThan:
			err := vm.executeComparison(OPCODE)
			if err != nil {
				return err
			}
		case code.OpBang:
			err := vm.executeBangOperator()
			if err != nil {
				return err
			}
		case code.OpMinus:
			err := vm.executeMinusOperator()
			if err != nil {
				return err
			}
		case code.OpJump:
			pos := int(code.ReadUint16(ins[ip+1:]))
			// Since we are looping through the array and incrementing Instruction Pointer each time, we have to set it
			// just before the instruction we want here
			vm.currentFrame().ip = pos - 1
		case code.OpJumpNotTruthy:
			pos := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip += 2 // Skip over the address encoded in OpJumpNotTruthy
			condition := vm.pop()
			if !isTruthy(condition) {
				vm.currentFrame().ip = pos - 1
			}
		case code.OpNull:
			err := vm.push(Null)
			if err != nil {
				return err
			}
		case code.OpSetGlobal:
			globalIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2
			vm.globals[globalIndex] = vm.pop()
		case code.OpGetGlobal:
			globalIndex := code.ReadUint16(ins[ip+1:])
			vm.currentFrame().ip += 2
			err := vm.push(vm.globals[int(globalIndex)])
			if err != nil {
				return err
			}
		case code.OpArray: // Doing what's described in code/code.go
			numElements := int(code.ReadUint16(ins[ip+1:])) // Decode the instruction
			vm.currentFrame().ip += 2                       // skip over the operands

			array := vm.buildArray(vm.sp-numElements, vm.sp) // Build array need a start and end address/index
			vm.sp = vm.sp - numElements                      // Clear the values which we don't need anymore after we've build the array!

			err := vm.push(array) // push the build array onto the stack and that's that!
			if err != nil {
				return err
			}
		case code.OpHash:
			numElements := int(code.ReadUint16(ins[ip+1:]))
			vm.currentFrame().ip += 2
			hash, err := vm.buildHash(vm.sp-numElements, vm.sp)
			if err != nil {
				return err
			}
			vm.sp = vm.sp - numElements
			err = vm.push(hash)
			if err != nil {
				return err
			}
		case code.OpIndex:
			// The order here has to match the order in the compiler
			// i.e. index is on top of the stack and the structure just below it
			index := vm.pop()
			left := vm.pop()
			err := vm.executeIndexExpression(left, index)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

// executeIndexExpression handles ast.IndexExpression by delegating work to appropriate subroutine based on type of the
// objects.
// An error may be returned if it does not know how to index into the given objects or if any error bubbles up from the
// works it delegated to.
func (vm *VM) executeIndexExpression(left, index object.Object) error {
	switch {
	case left.Type() == object.ARRAY_OBJ && index.Type() == object.INTEGER_OBJ:
		return vm.executeArrayIndex(left, index)
	case left.Type() == object.HASH_OBJ:
		return vm.executeHashIndex(left, index)
	default:
		return errors.New("index operator not supported on: " + string(left.Type()))
	}
}

// executeArrayIndex executes index expressions on object.Array.
// It expects the left to be a *object.Array and a right to be a *object.Integer, if either is not of this type an error
// is returned to the caller.
// It then calculates the max/min boundaries of the array and if the index is outside of them, Null is pushed onto the VM stack.
// An error may also be returned to the caller if the VM stack is overflowing.
// Otherwise, a value at the index is pushed onto the stack.
func (vm *VM) executeArrayIndex(left, index object.Object) error {
	arrayType, ok := left.(*object.Array)
	if !ok {
		return errors.New("index operator not supported on: " + string(arrayType.Type()))
	}
	indexObject, ok := index.(*object.Integer)
	if !ok {
		return errors.New("index operator not supported on: " + string(indexObject.Type()))
	}
	i := indexObject.Value
	max := int64(len(arrayType.Elements) - 1)
	if i < 0 || i > max {
		return vm.push(Null)
	}
	return vm.push(arrayType.Elements[i])
}

// executeHashIndex executes index expressions on object.Hash. It expects the hash to be of type *object.Hash and the index
// to meet the object.Hashable interface. If either is not as expected an error is returned to the caller. If the value
// at that hash key does not exist in the hash literal, a Null is pushed onto the VM stack.
// An error might also be returned if the VM stack overflows.
// Otherwise the value at the index is pushed onto the VM stack.
func (vm *VM) executeHashIndex(hash, index object.Object) error {
	hashType, ok := hash.(*object.Hash)
	if !ok {
		return errors.New("hash operator not supported on: " + string(hashType.Type()))
	}
	key, ok := index.(object.Hashable)
	if !ok {
		return errors.New("hash operator not supported on: " + string(index.Type()))
	}
	pair, ok := hashType.Pairs[key.HashKey()]
	if !ok {
		return vm.push(Null)
	}
	return vm.push(pair.Value)
}

// buildHash takes a start address and an end address on the stack. It then walks all these addresses building
// up a hash literal.
// An error might be returned if it encounters an *object.Object (key) which does not implement a object.Hashable
// interface.
// Otherwise, a pointer to a created *object.Hash is returned to the caller.
func (vm *VM) buildHash(startIndex, endIndex int) (object.Object, error) {
	hashedPairs := make(map[object.HashKey]object.HashPair)
	for i := startIndex; i < endIndex; i += 2 {
		key := vm.stack[i]
		value := vm.stack[i+1]

		pair := object.HashPair{Key: key, Value: value}
		hashKey, ok := key.(object.Hashable)
		if !ok {
			return nil, errors.New("unusable as hash key: " + string(key.Type()))
		}
		hashedPairs[hashKey.HashKey()] = pair
	}
	return &object.Hash{Pairs: hashedPairs}, nil
}

// buildArray accepts start index (an address on the stack) and end index (an address on the stack) for the array.
// It then walks all the locations between start and end indexes, collecting the values from the stack and adding them
// to the array which is then returned
func (vm *VM) buildArray(startIndex int, endIndex int) object.Object {
	elements := make([]object.Object, endIndex-startIndex)
	for i := startIndex; i < endIndex; i++ {
		elements[i-startIndex] = vm.stack[i]
	}
	return &object.Array{Elements: elements}
}

// isTruthy evaluates truthy monkey expressions and returns a Go native bool
func isTruthy(obj object.Object) bool {
	switch obj := obj.(type) {
	case *object.Boolean:
		return obj.Value
	case *object.Null:
		return false
	default:
		return true
	}
}

// executeMinusOperator handle the - prefix operator on integer operands.
// An error might be returned if the operand is not of type *object.Integer or if the VM stack overflows.
func (vm *VM) executeMinusOperator() error {
	operand := vm.pop()
	operandInteger, ok := operand.(*object.Integer)
	if !ok {
		return errors.New("operand is not an integer: " + string(operand.Type()))
	}
	if operandInteger.Type() != object.INTEGER_OBJ {
		return errors.New("operand is not an integer: " + string(operand.Type()))
	}
	integerValue := operandInteger.Value
	return vm.push(&object.Integer{Value: -integerValue})
}

// executeBangOperator handles the ! prefix operator on boolean values according to predefined logic.
// An error might be returned indicating a stack overflow in Monkey VM.
func (vm *VM) executeBangOperator() error {
	operand := vm.pop()

	switch operand {
	case True:
		return vm.push(False)
	case False:
		return vm.push(True)
	case Null:
		return vm.push(True)
	default:
		return vm.push(False)
	}
}

// executeComparison tries to evaluate boolean expressions (true != false, etc...) on the last two stack objects.
// If it fails an error is returned to the caller otherwise the boolean expression is evaluated, the operands are popped
// from the stack and the result is placed on it.
func (vm *VM) executeComparison(OPCODE code.Opcode) error {
	right, left := vm.pop(), vm.pop()
	if left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ {
		return vm.executeIntegerComparison(OPCODE, left, right)

	}
	switch OPCODE {
	case code.OpEqual:
		return vm.push(nativeBoolToBooleanObject(right == left))
	case code.OpNotEqual:
		return vm.push(nativeBoolToBooleanObject(right != left))
	default:
		return fmt.Errorf("unknown operator: %d (%s %s)", OPCODE, left.Type(), right.Type())
	}
}

// executeIntegerComparison is similar to executeComparison, but it's specific to *object.Integer objects.
// Both the left and the right have to be of this type...
func (vm *VM) executeIntegerComparison(op code.Opcode, left, right object.Object) error {
	leftIntegerObject, ok := left.(*object.Integer)
	if !ok {
		return errors.New("left object is not an integer: " + string(left.Type()))
	}
	rightIntegerObject, ok := right.(*object.Integer)
	if !ok {
		return errors.New("right object is not an integer: " + string(right.Type()))
	}
	leftValue, rightValue := leftIntegerObject.Value, rightIntegerObject.Value
	switch op {
	case code.OpEqual:
		return vm.push(nativeBoolToBooleanObject(rightValue == leftValue))
	case code.OpNotEqual:
		return vm.push(nativeBoolToBooleanObject(rightValue != leftValue))
	case code.OpGreaterThan:
		return vm.push(nativeBoolToBooleanObject(leftValue > rightValue))
	default:
		return fmt.Errorf("unknown operator: %d", op)
	}
}

// nativeBoolToBooleanObject transforms go booleans (true, false) into Monkey booleans (True, False).
// It is just a simple helper function.
func nativeBoolToBooleanObject(input bool) *object.Boolean {
	if input {
		return True
	}
	return False
}

// executeBinaryOperation executes all the infix operations by delegating them to the appropriate subroutines.
// If an error is produced (either by the called subroutine or by the fact that executeBinaryOperation does not know
// how to delegate work correctly) it's returned to the caller!
func (vm *VM) executeBinaryOperation(op code.Opcode) error {
	right, left := vm.pop(), vm.pop()
	leftType, rightType := left.Type(), right.Type()

	switch {
	case leftType == object.INTEGER_OBJ && rightType == object.INTEGER_OBJ:
		return vm.executeBinaryIntegerOperation(op, left, right)
	case leftType == object.STRING_OBJ && rightType == object.STRING_OBJ:
		return vm.executeBinaryStringOperation(op, left, right)
	default:
		return errors.New("unsupported types for binary operation: left=" + string(leftType) + " right=" + string(rightType))
	}
}

// executeBinaryStringOperation performs operations on string literals.
// An error can be returned if either object is not a *object.STRING_OBJ, the OPCODE is unknown or unsupported,
// or the VM stack overflows!
// Otherwise the result of the operation is pushed onto the VM stack.
func (vm *VM) executeBinaryStringOperation(op code.Opcode, left, right object.Object) error {
	if op != code.OpAdd {
		return errors.New("unknown string operator " + string(op))
	}
	leftType, ok := left.(*object.String)
	if !ok {
		return errors.New("left object is not a string: " + string(left.Type()))
	}
	rightType, ok := right.(*object.String)
	if !ok {
		return errors.New("right object is not a string: " + string(right.Type()))
	}
	leftValue, rightValue := leftType.Value, rightType.Value
	return vm.push(&object.String{Value: leftValue + rightValue})
}

// executeBinaryIntegerOperation knows how to perform arithmetic between integers.
// If an error is encountered (like one of the operands, left or right not being a *object.Integer or the VM encountering
// a stack overflow) this error is returned to the caller.
// Otherwise, the resulting value is pushed onto the VM stack.
func (vm *VM) executeBinaryIntegerOperation(op code.Opcode, left, right object.Object) error {
	leftType, ok := left.(*object.Integer)
	if !ok {
		return errors.New(string("invalid operand type on the left side: " + leftType.Type()))
	}
	rightType, ok := right.(*object.Integer)
	if !ok {
		return errors.New(string("invalid operand type on the right side: " + rightType.Type()))
	}
	leftValue, rightValue := leftType.Value, rightType.Value
	var result int64
	switch op {
	case code.OpAdd:
		result = leftValue + rightValue
	case code.OpSub:
		result = leftValue - rightValue
	case code.OpMul:
		result = leftValue * rightValue
	case code.OpDiv:
		result = leftValue / rightValue
	default:
		return fmt.Errorf("unknown integer operator: %d", op)
	}
	return vm.push(&object.Integer{Value: result})
}

// push taken an object.Object and tries to push it onto the VM stack.
// To try and do this, it first checks that VM stack size is not equal or larger to StackSize. If it is, an error of
// stack overflow is returned to the caller.
// Otherwise, it adds the object to the VM stack at the current stack pointer (sp) and then increments this sp.
// In case of success nil is returned to the caller.
func (vm *VM) push(o object.Object) error {
	if vm.sp >= StackSize {
		return errors.New("stack overflow")
	}
	vm.stack[vm.sp] = o
	vm.sp++
	return nil
}

// pop pops an object from VM stack and decrements the stack pointer, sp.
// Popped object is returned to the caller.
// If VM's stack is empty, a nil is returned to the caller instead!
func (vm *VM) pop() object.Object {
	if vm.sp == 0 {
		return nil
	}
	topObject := vm.stack[vm.sp-1]
	vm.sp--
	return topObject
}
