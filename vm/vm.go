package vm

import (
	"errors"
	"github.com/blazskufc/interpreter_in_go/code"
	"github.com/blazskufc/interpreter_in_go/compiler"
	"github.com/blazskufc/interpreter_in_go/object"
)

const StackSize = 2048

// VM represent a Monkey Virtual Machine - The heart of the bytecode interpreter, which executes/evaluates bytecode
// produced by compiler.Compiler.
// Monkey virtual machine is a stack based virtual machine.
type VM struct {
	constants    []object.Object   // constants are the evaluated literals and other constants from the compiler.Compiler constants pool
	instructions code.Instructions // instructions are the bytecode instructions produced by compiler.Compiler
	stack        []object.Object   // stack is the Monkey virtual machine stack
	// sp is the Stack Pointer (https://www.techtarget.com/whatis/definition/stack-pointer).
	// It always points to the next value.
	// Top of the stack is stack[ sp -1 ].
	sp int
}

// New returns a pointer to a new, initialized, Monkey virtual machine.
// Note that VM.stack is initialized to a slice with size of StackSize.
// VM.sp is initialized to 0, as you might expect.
func New(bytecode *compiler.Bytecode) *VM {
	return &VM{
		constants:    bytecode.Constants,
		instructions: bytecode.Instructions,
		stack:        make([]object.Object, StackSize),
		sp:           0,
	}
}

// StackTop returns an object.Object on top of the stack, object at position VM.stack[VM.sp - 1], to the caller.
// If the VM stack is empty, nil is returned to the caller instead!
func (vm *VM) StackTop() object.Object {
	if vm.sp == 0 {
		return nil
	}
	return vm.stack[vm.sp-1]
}

// Run is the heartbeat itself of the Monkey virtual machine, if you take analogy of the VM structure being a heart.
// It mimics and performs the fetch–decode–execute cycle (https://en.wikipedia.org/wiki/Instruction_cycle) on the
// bytecode generated by compiler.Compiler.
func (vm *VM) Run() error {
	for instructionPointer := 0; instructionPointer < len(vm.instructions); instructionPointer++ {
		// We take the first byte, which is always a OPCODE and we cast it said type.
		// Note that it's important that we do not use  code.Lookup here to get from a byte to an Opcode.
		// That would be far TOO SLOW. It costs time to move the byte around, lookup the opcode’s definition, return
		// it and take it apart.
		OPCODE := code.Opcode(vm.instructions[instructionPointer])
		switch OPCODE {
		case code.OpConstant:
			// code.OpConstant are uint16 indexes into the constants pool.
			// Therefore, what we need to do first is decode this number, the index.
			constIndex := code.ReadUint16(vm.instructions[instructionPointer+1:])
			instructionPointer += 2 // Again, since code.OpConstant is uint16 this means we need to advance 2 bytes afterward
			// This is the execute part of the fetch-decode-execute cycle for constants/literals
			// We push the constant onto the VM's stack!
			err := vm.push(vm.constants[constIndex])
			if err != nil {
				return err
			}
		case code.OpAdd:
			leftValue, ok := vm.pop().(*object.Integer)
			if !ok {
				return errors.New(string("invalid operand type on the left side: " + leftValue.Type()))
			}
			rightValue, ok := vm.pop().(*object.Integer)
			if !ok {
				return errors.New(string("invalid operand type on the right side: " + rightValue.Type()))
			}
			if err := vm.push(&object.Integer{Value: leftValue.Value + rightValue.Value}); err != nil {
				return err
			}
		}
	}
	return nil
}

// push taken an object.Object and tries to push it onto the VM stack.
// To try and do this, it first checks that VM stack size is not equal or larger to StackSize. If it is, an error of
// stack overflow is returned to the caller.
// Otherwise, it adds the object to the VM stack at the current stack pointer (sp) and then increments this sp.
// In case of success nil is returned to the caller.
func (vm *VM) push(o object.Object) error {
	if vm.sp >= StackSize {
		return errors.New("stack overflow")
	}
	vm.stack[vm.sp] = o
	vm.sp++
	return nil
}

// pop pops an object from VM stack and decrements the stack pointer, sp.
// Popped object is returned to the caller.
// If VM's stack is empty, a nil is returned to the caller instead!
func (vm *VM) pop() object.Object {
	if vm.sp == 0 {
		return nil
	}
	topObject := vm.stack[vm.sp-1]
	vm.sp--
	return topObject
}
